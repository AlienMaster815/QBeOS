# What?

this text file documents a lot of the design assumptions that are made for QBeOS.
it also describes the output files and their formats produced from the build process step by step.

# road map
Highlevel overview of the road map of development for QBeOS
* GDT // done
* PMM
* VMM
* PAGING
* IDT
* LDT
* TSS
* SIMD
* ACPI
* APIC
* IOAPIC
* LAPIC
* HPET
* APIC-TIMER
* SMP
* Multitasking
* Syscalls
* Userspace
* The fun begin

TODOs - Technical Debt stemming from the fact of how excited I am to go to user mode:
* Implement EFI loading
* Switch to CMake at some point

# QBeOS components and dir structure

QBeOS kernel : /src : c++
QBeOS bootloader : /boot : assembly NASM

QBeOS will only be iso bootable. ISO 9660 will be the first supported fs.
This allows 2046 bytes bootloader; a 2kb boot loader to be loaded!! maybe no need for 2 stages?
we will see.

# Bootloader

the bootloader in boot directory contains all assembly files required to build the bootloader. NASM is used for this task.
the main file bootloader.asm contains all required files and is the main entry to the bootloader. inside this file, other files
are imported that holds other functionalities. separation is good.
The bootloader file is heavily commented. This serves as the documentation for the bootloader. Eventually comments are stripped
once the files go through the compiler.
I know the good code is the one that never requires comments but this is assembly code we are talking about and I need to
document my desgin assumptions for myself.

## List of important assumptions made
* the kernel and bootloader exist both in the root directory. There are no other directories on the CD


## Memory Map during the bootloading time
Lookup memory_layout.md first.

START            END          SIZE           description
0x00000          0x003ff      1KB            RealMode IVT
0x00400          0x004ff      256B           BIOS Data Area (BDA)
0x00500          0x00d00      2KB            PVD of QBeOS ISO
0x00d00          0x02d00      8KB            Bootloader buffers area
0x02d00          0x07bff      19.75KB        QBeOS Bootloader (BL) stack
0x07c00          0x083ff      2KB            QBeOS BL
0x08400          0x6ffff      479Kb          QBeOS Kernel
0x70000          0x7ffff      64KB           Memory Layout Table
0x80000          0x100000     512KB          Bios Data <- don't mess with this
0x100000         0x10ffff     64KB           High Memory Area in Real mode
------------------------------  Protected Mode -------------------------------
0x00110000       0x003fffff   2MB            OS Stack
0x00400000       0x004fffff   1MB            GDT table
0x00500000       0x04500000   64MB           Memory tables





# QBeOS Kernel

for now, this is just one cpp file.

the output of this module is the KERNEL.IMG binary file.

## Important
.. keep this here. important learning
I have discovered that if I want to write a kernel that is bigger than 400KBs (conventional memory available below 1Mib Boundry)
I need to load it into memory beyond the 1Mib boundry. in real mode, beyond the 1Mib boundry only 64Kbs available so that means
the size of my kernel can't be bigger than 464Kbs. at the time of writing this, my basic, not so good, kernel that only writes
stuff to screen is 1.2Kb. I have naively thought I could trick the BIOS bytes setting the pointer to the buffer where the
kernel is loaded to the 1Mib boundary exactly, hoping the BIOS will be able to do so itself (i.e, access memory beyond 1Mib +
64Kb) but the BIOS was.. well.. smarter or dumber than me.. eventually I researched osdev and found out that BIOS is not reliable in loading
stuff above 1Mib, but I can load below 1Mib and relocate data there.

so taking a pause here to evaluate these two decisions:

* Continue as I am now, and leave this problem for future me.
**Changes:
*** I will restructure the memory layout to load the kernel in a lower address.

** Pros:
*** short - no changes really
*** get to the good stuff (the actual OS things)

** Cons:
*** may struggle when I hit the limits of the 1Mib memory while loading the kernel

* Implement a solution for this.
**Changes:
*** to talk to higher memroy I need to be in protected mode. When I am in protected mode, I will not be able to use BIOS
    Interrupts which means I will not be able to load the kernel while in real mode before jumping to protected mode. That means,
    to load the kernel I will have to jump to protected mode and load the kernel via a driver. this is already smelling like 2
    stage bootloader.

# Memory management
The essential objective of memory management is to implement how addresses are
translated and memory access control. There are three types of addresses into
memory.
Virtual address(AKA logical address), linear address, physical address.
At the end of the day physical address is the address used to access the memory.
If we have a flat memory model, i.e, Code Segment == Data Segment == The whole
whole memory as a limit (this is set by having 2 GDT entries spanning the whole
memory limits), then, Virtual address is the same as a linear address.
this is because linear address is produced from virtual address by means of
segmentation. The virtual address consists of 16 bit selector and 32 bit offset.
The selectors are selectors into the GDT or LDT depending on the context.
LDT is associated with tasks. When in flat memory model, the selectors
are preloaded during boot after switching to protected mode from real mode.
The physical address is calculated from the linear address via paging. the linear
address is split into 10 10 12 bits. The first 10 bits point into page directory.
it is the index of a page directory entry. A page directory entry then points to
a page table. The second 10 bits point into the index of a page table entry.
A page table entry points to the start of a page in physical memory. the last 12
bits is the index of the byte in the page. That means each page can be 4096 byte
or 4kbs.
likewise, if paging is disabled then Virtual address maps to linear address via
the GDT and linear address in this case is the same as physical address.

in conclusion, segmentation and paging are two different memory protection modes.
they can be used together or one can be used but not the other. segemntation can
be used to isolate tasks in a multitasking or multiprocess environments. the
latter is the environment you get when the CPU has multicores.


Note: All of this information can be found in intel manuals Vol3 Chapter 3.
# QBeOS Memory Management model
Right after the bootloader is done and before jumping to the kernel, the memory
model is flat memory model. i.e, both code and data descriptors in GDT map to
the whole available memory address space.

QBeOS for the time being is 32 bit OS (TODO: Switch to 64 bits)

After booting, QBeOS defines 4 segments in GDT spanning the whole memory, 2 for
kernel code and data, and 2 for user code and data + 1 null descriptor:
index          | Base           | LIMIT         | Description
0              | 0              | 0             | null descriptor
1              | 0x00000000     | 0xFFFFF       | executable kernel code
2              | 0x00000000     | 0xFFFFF       | nonexecutable kernel data
3              | 0x00c00000     | 0xFFFFFF      | user executable
4              | 0x00c00000     | 0xFFFFFF      | user data

The purpose of this segmentation model is just to protect kernel area from user
area and rely on paging to protect kernel and user code from each other as well.
GDT will be used for LDT and TSS as well.

# MemoryManager
the memory manager is responsible for the physical memory. The memory manager is just that
a memory manager. It should not know how low level things are done. For that there
should be components that does that. It should also be the only gateway to memory
operations. The memory manager understands how to manage the memory components to
fulfill the APIs implementation. The component implementing the memory manager is Memory.
Memory is initialized by reading the memory tables placed by the bootloader at 0x70000.
It then initializes the memory allocator to be able to allocate physical pages of memory.
Each page will be of size PAGE_SIZE(4k).
Post initialization, Memory marks the pages used by the OS as reserved for os.

Memory Public API (Size is in bytes):
AllocatePage(): searches for the first free page and allocates it. return pointer to base of page
Allocate(size): allocates X + (X + PAGE_SIZE) % PAGE_SIZE pages and returns pointer to first page.
FreePage(pagePointer): given a page pointer that begins on the page boundary, free corresponding page.
Free(pagePointer): given a pointer that begins on the page boundary, free all corresponding pages.
